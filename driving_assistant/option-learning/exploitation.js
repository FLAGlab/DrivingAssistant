const Trait = require('./traits.js').Trait
const cop = require('./context-traits.js')

const fs = require('fs')
const path = require('path');

function Agent(world) {
  //environmet in which the agent lives
  this.world = world
  //agent specific state
  this.speed = 50
  //lane: 0 = right, 1 = left
  this.position = {"lane": 0, "column":10}
  this.collisionTime = 4
  //this.passenger = NaN
  this.actions = getMethods(Agent.prototype)
} 
/*
Agent.prototype.stop = function() {
  this.speed = 0
}
*/
Agent.prototype.straight = function() {
  //do nothing
  masterCounter++
  this._getState()
}

Agent.prototype.slowDown = function() {
  masterCounter++
  if(this.speed > 0)
        this.speed -= 10
  this._getState()
}

Agent.prototype.speedUp = function() {
  masterCounter++
  if(this.speed < 80)
        this.speed += 10
  this._getState()
}

Agent.prototype.steerLeft = function() {
  masterCounter++
  //if(!this.position.lane)
      this.position.lane = 1
  /*else
      this.speed = 0
      */
  this._getState()
}

Agent.prototype.steerRight = function() {
  masterCounter++
  //if(this.position.lane)
      this.position.lane = 0
 /* else    
      this.speed = 0
      */
  this._getState()
}

Agent.prototype._timeToCollision = function() {
  let cars = this.world.otherCars.filter(car => car.position.lane == this.position.lane)
  let distances = cars.map(car => {
      let dx = Math.round((car.position.column - this.position.column) ) * 0.005
      let dv = this.speed - car.speed
      let dt = 100
      if(dv != 0) 
          dt = (Math.round((dx/dv * 200)*2)/2 );
      return dt
  })
  let ordered = distances.sort()
  let dt = ordered.length == 0 ? 100 :  ordered[0]
  if(dt >0 && dt < 20) {
    this.collisionTime = 1
    return 1
  } else if(dt >=20 && dt < 30) {
      this.collisionTime = 2
      return 2 //it can still slow down
  } else if(dt>=30 && dt < 50) {
      this.collisionTime = 3
      return 3
  } else {
      this.collisionTime = 4
      return 4		
  }	
}

Agent.prototype._checkCrashed = function() {
  if(this.speed != 0)
      this.world.otherCars.forEach(c => {
          if(c.position.lane == this.position.lane) {
              var dx = c.position.column - this.position.column
              if(dx < 100) {
                  this.speed = 0
                  c.position.column = -1
              }
          }
      })
}

Agent.prototype._getState = function() {
  //state: {speed, lane, proximity}
  this.world.moveCarsLeft(this)
  this._checkCrashed()
  this.world.otherCars = this.world.otherCars.filter(c => c.position.column > 0)
  return [this.speed, this.position.lane, this._timeToCollision()]
}

Agent.prototype._loadContexts = function(name) {
  var fn = path.join(__dirname, `./${name}.txt`);
  var contents = fs.readFileSync(fn).toString();
  var lines = contents.split("\n");
  stateOptionsMap = JSON.parse(lines[0])
  for(var i=1; i<lines.length; i++) {
      let line = lines[i]
      if(line.includes("adapt")) {
        eval(line)
      } else if(line.startsWith("Context")) {
        eval(line)
      } else if(line.startsWith("BA")) {
        eval(line)
      }
  }
}

Agent.prototype._recordAdaptations = function(indices) {
  var fn = path.join(__dirname, './options.txt');
  var contents = fs.readFileSync(fn).toString();
  var lines = contents.split("\n");
  let adaptation = ""
  let primitiveSize = this.actions.length
  let closing = false
  var stream = fs.createWriteStream("./adaptations.txt")
  let optionsCount = {}
  indices.forEach(elem => optionsCount[Object.keys(elem)[0]] = 1)
  stream.once('open', function(fd) {
      stream.write(`${JSON.stringify(optionsCount)}\n`)
      Object.values(indices).forEach(s => {
          let key = Object.keys(s)[0]
          let state = `${key.replace(/,/g,'')}${s[key]}`
          let contextName = `Context${state - primitiveSize}`
          for(var i=1; i<lines.length; i++) {
              let line = lines[i]
              if(line.startsWith(contextName))  {
                  stream.write(line + '\n')
              } else if(line.startsWith(`BA${contextName}`)) {
                  adaptation = line
                  closing = true
              } else if(closing && line.startsWith("})")) {
                  adaptation += line
                  stream.write(adaptation + '\n')
                  closing = false
              } else if(closing) {
                  adaptation += line
              }
          }
      })
      stream.end()
  })
}

function getMethods(obj) {
  return Object.getOwnPropertyNames(obj).
      filter(item => typeof obj[item] === 'function' && !item.startsWith('_') && item != 'constructor')
}

/* 
 * environment definition
 */
function World() {
    this.width = 500
    this.height = 4
    this.timeForFullDistance = 0.01
    this.speedIntervals = 5
    this.density = 0.33
    this.exploration = 0.2
    this.otherCars = []
}

World.prototype.carB = function() {
    let otherSpeeds = [30]
    let id = Math.floor(Math.random()*(9999-999+1)+999);
    let speed = otherSpeeds[Math.floor(Math.random() * otherSpeeds.length)];
    let position = {"lane": 0, "column":this.width};
    //console.log(`car added to lane ${position.lane} with speed ${speed}`)
    this.otherCars.push({"id": id, "speed": speed, "position": position, "spawnTime": this.currentTime()})
}

World.prototype.moveCarsLeft = function(agent) {
  if(agent.speed != 0)
    this.otherCars.forEach(car => {
      let relativeSpeed = (agent.speed - car.speed)
      var dt = this.currentTime() -  car.spawnTime;
      //var d = -(relativeSpeed * (dt/(0.005*1000))/100) + car.position.column;
      var d = Math.min(-(relativeSpeed * 10) + car.position.column, 1000)
      car.spawnTime = this.currentTime()
      car.position.column = d
    })
  //check if out of bounds
  //this.otherCars = this.otherCars.filter(c => c.position.column > 0)
}

World.prototype.currentTime = function() {
  var d = new Date();
  return  d.getTime();
}

World.prototype.addCars = function() {
    if(this.otherCars.length == 0 && steps >= 3 && Math.random() < this.density) {
      this.carB()
      steps = 0
      generated++
    }
}

//--------------- RUNNING --------------
masterCounter = 0
optionCounter = 0
steps = 0
generated = 0
stateOptionsMap = {}
stateFrequenciesMap = {}
w = new World()
agent = new Agent(w)
currentState = agent._getState()
agent._loadContexts("adaptations")
let qtable = []

function main() {
  var alpha = 0.1
  var gamma = 0.6
  var epsilon = 0.001
  
  console.log(agent.actions)
  qtable = loadQTable()
  let data = "Speed,Lane,Proximity,action,Speed,next_lane,next_proximity,crashes,wrong_lane,over_limit\n"
  let action = -1
  let crashes = 0, wrongLanes = 0, overSpeed = 0
  let i = 0
  let result = []
  while(i < 8000) {
    let actions = agent.actions
    if(Math.random() < epsilon)
      action = randomAction(actions)
    else 
      action = qtable[currentState].map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1]
    //result = [next_sate, reward, donde, info]
    if(action >= actions.length) {
      let state = currentState.toString().replace(/,/g,'')
      let adaptation = state
      eval(`Context${adaptation}.activate()`)
      agent.option()
      optionCounter++    
      next_state = [agent.speed, agent.position.lane, agent.collisionTime]
      reward_done = getRewards(next_state, action)
      /*if(reward_done[0] > 0) {
        let frequency = stateFrequenciesMap[`${currentState}`]
        reward_done[0] *= frequency
      }*/
    } else {
      eval(`agent.${actions[action]}()`)
      next_state = [agent.speed, agent.position.lane, agent.collisionTime]
      reward_done = getRewards(next_state, action)
    }
    
    info = `Executed action: ${actions[action]} at state ${currentState}`
    result = [next_state, reward_done[0], reward_done[1], info]
    oldValue = qtable[currentState][action]
    nextMax = Math.max.apply(Math, qtable[result[0]])
    newValue = (1- alpha)*oldValue + alpha*(result[1] + gamma*nextMax)
    qtable[currentState][action] = newValue
    
    //print to file
    data += `${currentState},${actions[action]},${result[0]},${crashes},${wrongLanes},${overSpeed}\n`
    if(result[0][0] == 0) 
      crashes++
    else if(result[0][0] > 60)
      overSpeed++
    if(result[0][1] == 1)
      wrongLanes++
    currentState = result[0]
    
    //done = result[2]
    agent.world.addCars()
    i++
    steps++
  }
  console.log(generated)
  console.log(`Executed options: ${optionCounter}`)
  console.log(`Executed actions: ${masterCounter}`)
  fs.writeFile(`./option_exploitation.csv`, data, function (err,data) {
    if (err) 
      return console.log(err)
    console.log(data)})
}

function randomAction(actions) {
  return randInt(0, actions.length - 1)
}

function getRewards(state, action) {
  if(state[0] == 0)
    return [-800, false] //crash
  else if(state[0] > 60)
    return [-600, false]  //fast
  else if(state[0] < 50)
    return [-600, false]  //slow
  else if(state[1] == 1)
    return [-500, false] //wrong lane
  else if(state[2] == 4)
    if(action > agent.actions.length)
      return [1000 / action, false] //no car infront
    else
      return [50, false]
  else
    return [0, false]
}

/*change function */
function loadQTable() {
  table = {}
  var fn = path.join(__dirname, './qtable.txt')
  var contents = JSON.parse(fs.readFileSync(fn).toString())
  return contents
}

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min) ) + min;
}

main()